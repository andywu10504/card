<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>抽卡小工具</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap 5 + jQuery -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Font Awesome -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

  <style>
    body {
      background: #f7f7f9;
      padding-bottom: 100px; /* 給固定按鈕一點空間，避免內容被遮住 */
    }

    /* 圖片區：撐滿 Nav 與按鈕之間，RWD */
    .card-preview {
      width: 100%;
      height: calc(100vh - 180px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 16px;
    }

    @media (max-width: 576px) {
      .card-preview {
        height: calc(100vh - 190px); /* 手機再多留一點給按鈕 */
      }
    }

    #card-img {
      max-width: 100%;
      max-height: 100%;
      border-radius: .5rem;
      border: 3px solid #343a40;
      background: #e9ecef;
      object-fit: contain;
      display: block;
    }

    /* 抽卡按鈕固定在底部，略往上留距離 */
    #btnDrawContainer {
      position: fixed;
      bottom: 16px;
      left: 0;
      right: 0;
      z-index: 10;
      padding: 0 20px;
    }
  </style>
</head>
<body>

<!-- Navbar -->
<nav class="navbar bg-body-tertiary px-3 mb-2">
  <a class="navbar-brand fw-bold" href="#">抽卡小工具</a>

  <div class="ms-auto d-flex align-items-center gap-2">
    <!-- 歷史區 -->
    <button id="btnHistory" class="btn btn-outline-secondary btn-sm" type="button"
            data-bs-toggle="modal" data-bs-target="#historyModal">
      <i class="fa-solid fa-clock-rotate-left"></i>
    </button>

    <!-- 全螢幕 -->
    <button id="btnFullscreen" class="btn btn-outline-secondary btn-sm" type="button">
      <i class="fa-solid fa-expand"></i>
    </button>

    <!-- 設定（右側 offcanvas） -->
    <button class="btn btn-outline-secondary btn-sm"
            type="button"
            data-bs-toggle="offcanvas"
            data-bs-target="#settingsPanel">
      <i class="fa-solid fa-sliders"></i>
    </button>
  </div>
</nav>

<!-- 右側 Offcanvas 設定面板 -->
<div class="offcanvas offcanvas-end" tabindex="-1" id="settingsPanel">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title">設定區</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
  </div>

  <div class="offcanvas-body">
    <!-- 牌組選擇 -->
    <div class="mb-3">
      <label for="deckSelect" class="form-label">選擇牌組</label>
      <select id="deckSelect" class="form-select"></select>
    </div>

    <!-- 滾動時間 -->
    <div class="mb-3">
      <label for="spinDuration" class="form-label">滾動時間（秒）</label>
      <input type="number" id="spinDuration" class="form-control"
             min="0.3" step="0.1" value="2.0">
      <div class="form-text">抽卡轉動持續時間</div>
    </div>

    <!-- 是否允許重複出卡 -->
    <div class="form-check mb-3">
      <input class="form-check-input" type="checkbox" id="allowDuplicate" checked>
      <label class="form-check-label" for="allowDuplicate">
        允許重複出卡
      </label>
    </div>

    <hr>

    <!-- 背景音樂 -->
    <div class="mb-3">
      <label class="form-label">背景音樂（BGM）</label>
      <div class="d-grid gap-2 mb-2">
        <button id="btnTestBgm" class="btn btn-outline-success">
          測試背景音樂 / 播放 / 暫停
        </button>
      </div>
      <label for="bgmVolume" class="form-label small mb-1">
        背景音樂音量
      </label>
      <input type="range" id="bgmVolume" class="form-range"
             min="0" max="1" step="0.01" value="0.5">
    </div>

    <!-- 滾動音效音量 -->
    <div class="mb-3">
      <label for="sfxVolume" class="form-label small mb-1">
        滾動／停頓音效音量
      </label>
      <input type="range" id="sfxVolume" class="form-range"
             min="0" max="1" step="0.01" value="0.8">
    </div>

    <!-- 測試音效 -->
    <div class="d-grid">
      <button id="btnTestSound" class="btn btn-outline-primary">
        測試滾動音效
      </button>
    </div>
  </div>
</div>

<!-- 主畫面 -->
<div class="container-fluid">

  <!-- 卡片顯示（會自動撐滿 Navbar 和按鈕之間） -->
  <div class="card-preview">
    <img id="card-img" src="" alt="">
  </div>

  <!-- 抽卡按鈕（固定在底部） -->
  <div id="btnDrawContainer" class="d-grid">
    <button id="btnDraw" class="btn btn-primary btn-lg">
      開始抽卡
    </button>
  </div>
</div>

<!-- 歷史區 Modal -->
<div class="modal fade" id="historyModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">抽卡歷史紀錄</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <!-- 篩選牌組 -->
        <div class="mb-2 d-flex align-items-center gap-2 flex-wrap">
          <label for="historyFilterDeck" class="form-label mb-0 small">顯示牌組</label>
          <select id="historyFilterDeck" class="form-select form-select-sm" style="max-width: 220px;">
            <option value="">全部牌組</option>
          </select>
        </div>

        <ul id="historyList" class="list-group small">
          <!-- 由 JS 填入 -->
        </ul>
        <div id="historyEmpty" class="text-muted text-center py-3 d-none">
          尚無抽卡紀錄
        </div>
      </div>
      <div class="modal-footer">
        <button id="btnClearHistory" type="button" class="btn btn-outline-danger btn-sm">
          清除歷史紀錄
        </button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">關閉</button>
      </div>
    </div>
  </div>
</div>

<script>
  // ============================
  // LocalStorage key 設定
  // ============================
  const LS_PREFIX        = 'cardTool_';
  const LS_KEY_DECK      = LS_PREFIX + 'lastDeck';
  const LS_KEY_BGM       = LS_PREFIX + 'bgmVolume';
  const LS_KEY_SFX       = LS_PREFIX + 'sfxVolume';
  const LS_KEY_HISTORY   = LS_PREFIX + 'history';
  const LS_KEY_ALLOW_DUP = LS_PREFIX + 'allowDuplicate';

  // ============================
  // 牌組資料（從 decks.json 載入）
  // ============================
  let DECKS = {};              // 以 id 為 key 存
  let initialDeckId = null;    // 從 localStorage 還原用
  let history = [];            // 抽卡歷史
  const usedCardsByDeck = {};  // 不重複出卡時使用：{ deckId: Set(cardFile) }

  // --- 新增：牌組預載狀態 ---
  function preloadDeck(deckId) {
    const deck = DECKS[deckId];
    if (!deck || !Array.isArray(deck.cards) || deck.cards.length === 0) {
      return Promise.resolve();
    }
    // 已經有 preload Promise 就直接用
    if (deck._preloadPromise) return deck._preloadPromise;

    deck._preloadPromise = new Promise(resolve => {
      let remaining = deck.cards.length;
      if (remaining === 0) {
        resolve();
        return;
      }
      deck.cards.forEach(file => {
        const img = new Image();
        img.onload = img.onerror = () => {
          remaining--;
          if (remaining <= 0) {
            resolve();
          }
        };
        img.src = deck.path + file;
      });
    });

    return deck._preloadPromise;
  }

  async function loadDecksFromJson() {
    try {
      const res = await fetch('decks.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('載入 decks.json 失敗');
      const data = await res.json();

      DECKS = {};
      if (Array.isArray(data.decks)) {
        data.decks.forEach(d => {
          if (d.id && d.path && Array.isArray(d.cards)) {
            DECKS[d.id] = d;
          }
        });
      }

      initDeckSelect();

      // 若有記憶的牌組，也先幫忙預載
      if (initialDeckId && DECKS[initialDeckId]) {
        await preloadDeck(initialDeckId);
      }
    } catch (err) {
      console.error(err);
      alert('載入牌組資料失敗，請檢查 decks.json 路徑與格式。');
    }
  }

  function initDeckSelect() {
    const $sel = $("#deckSelect");
    $sel.empty().append(`<option value="">請選擇牌組</option>`);
    Object.keys(DECKS).forEach(k => {
      $sel.append(`<option value="${k}">${DECKS[k].label || k}</option>`);
    });

    // 還原最後使用牌組
    if (initialDeckId && DECKS[initialDeckId]) {
      $sel.val(initialDeckId);
    }
  }

  // ============================
  // 全螢幕切換
  // ============================
  const fsBtn = document.getElementById('btnFullscreen');
  const fsIcon = fsBtn.querySelector('i');

  function isFullscreen() {
    return document.fullscreenElement ||
           document.webkitFullscreenElement ||
           document.mozFullScreenElement ||
           document.msFullscreenElement;
  }

  function requestFullscreen(elem) {
    if (elem.requestFullscreen) return elem.requestFullscreen();
    if (elem.webkitRequestFullscreen) return elem.webkitRequestFullscreen();
    if (elem.mozRequestFullScreen) return elem.mozRequestFullScreen();
    if (elem.msRequestFullscreen) return elem.msRequestFullscreen();
  }

  function exitFullscreen() {
    if (document.exitFullscreen) return document.exitFullscreen();
    if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
    if (document.mozCancelFullScreen) return document.mozCancelFullScreen();
    if (document.msExitFullscreen) return document.msExitFullscreen();
  }

  fsBtn.addEventListener('click', () => {
    if (!isFullscreen()) {
      requestFullscreen(document.documentElement);
    } else {
      exitFullscreen();
    }
  });

  document.addEventListener('fullscreenchange', () => {
    if (isFullscreen()) {
      fsIcon.classList.remove('fa-expand');
      fsIcon.classList.add('fa-compress');
    } else {
      fsIcon.classList.remove('fa-compress');
      fsIcon.classList.add('fa-expand');
    }
  });

  // ============================
  // 背景音樂 BGM
  // ============================
  const BGM_SRC = './BGM_Iframe Jazzy Frenchy.mp3';  // ★ 路徑不同改這裡
  const bgm = new Audio(BGM_SRC);
  bgm.loop = true;
  bgm.volume = 0.5;

  const bgmVolumeSlider = document.getElementById('bgmVolume');
  const sfxVolumeSlider = document.getElementById('sfxVolume');
  const allowDupCheckbox = document.getElementById('allowDuplicate');
  const historyFilterSelect = document.getElementById('historyFilterDeck');

  function savePreferences() {
    try {
      localStorage.setItem(LS_KEY_BGM, bgmVolumeSlider.value);
      localStorage.setItem(LS_KEY_SFX, sfxVolumeSlider.value);
      localStorage.setItem(LS_KEY_DECK, document.getElementById('deckSelect').value || '');
      localStorage.setItem(LS_KEY_ALLOW_DUP, allowDupCheckbox.checked ? 'true' : 'false');
    } catch (e) {
      console.warn('無法寫入 localStorage(preferences)', e);
    }
  }

  function saveHistory() {
    try {
      localStorage.setItem(LS_KEY_HISTORY, JSON.stringify(history));
    } catch (e) {
      console.warn('無法寫入 localStorage(history)', e);
    }
  }

  function loadPreferencesFromLocalStorage() {
    try {
      const bgmV = localStorage.getItem(LS_KEY_BGM);
      if (bgmV !== null) {
        bgmVolumeSlider.value = bgmV;
        bgm.volume = parseFloat(bgmV) || 0;
      }

      const sfxV = localStorage.getItem(LS_KEY_SFX);
      if (sfxV !== null) {
        sfxVolumeSlider.value = sfxV;
        sfxVolume = parseFloat(sfxV) || 0.8;
      }

      const deckId = localStorage.getItem(LS_KEY_DECK);
      if (deckId) {
        initialDeckId = deckId;
      }

      const allowDup = localStorage.getItem(LS_KEY_ALLOW_DUP);
      if (allowDup !== null) {
        allowDupCheckbox.checked = allowDup === 'true';
      }

      const hRaw = localStorage.getItem(LS_KEY_HISTORY);
      if (hRaw) {
        const arr = JSON.parse(hRaw);
        if (Array.isArray(arr)) {
          history = arr
            .filter(x => x && x.deckId && x.card)
            .slice(0, 200); // 做個上限
        }
      }
    } catch (e) {
      console.warn('讀取 localStorage 失敗', e);
    }
  }

  bgmVolumeSlider.addEventListener('input', () => {
    const v = parseFloat(bgmVolumeSlider.value) || 0;
    bgm.volume = v;
    savePreferences();
  });

  document.getElementById('btnTestBgm').addEventListener('click', async () => {
    try {
      if (bgm.paused) {
        await bgm.play();
      } else {
        bgm.pause();
      }
    } catch (e) {
      console.error(e);
      alert('無法播放背景音樂，請檢查音樂檔路徑。');
    }
  });

  // ============================
  // Web Audio：slot machine 風格音效（含音量拉霸）
  // ============================
  let audioCtx = null;
  let sfxVolume = parseFloat(sfxVolumeSlider.value) || 0.8;

  sfxVolumeSlider.addEventListener('input', () => {
    const v = parseFloat(sfxVolumeSlider.value);
    sfxVolume = isNaN(v) ? 0.8 : v;
    savePreferences();
  });

  allowDupCheckbox.addEventListener('change', savePreferences);

  function ensureAudio() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  // 轉輪中的「喀喀喀」聲
  function playSlotTick() {
    ensureAudio();
    if (!audioCtx || sfxVolume <= 0) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;

    osc.type = "square";
    osc.frequency.setValueAtTime(900, now);
    osc.frequency.exponentialRampToValueAtTime(700, now + 0.05);

    gain.gain.setValueAtTime(0.0, now);
    gain.gain.linearRampToValueAtTime(0.25 * sfxVolume, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.07);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(now);
    osc.stop(now + 0.08);
  }

  // 最後停下來那一下
  function playFinalStop() {
    ensureAudio();
    if (!audioCtx || sfxVolume <= 0) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;

    osc.type = "triangle";
    osc.frequency.setValueAtTime(500, now);
    osc.frequency.exponentialRampToValueAtTime(280, now + 0.18);

    gain.gain.setValueAtTime(0.0, now);
    gain.gain.linearRampToValueAtTime(0.4 * sfxVolume, now + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(now);
    osc.stop(now + 0.24);
  }

  // 測試音效：一串 tick + 一聲 stop
  function testSound() {
    ensureAudio();
    if (!audioCtx || sfxVolume <= 0) return;
    const ticks = 8;
    const interval = 90;
    for (let i = 0; i < ticks; i++) {
      setTimeout(() => playSlotTick(), i * interval);
    }
    setTimeout(() => playFinalStop(), ticks * interval + 80);
  }

  document.getElementById('btnTestSound').addEventListener('click', testSound);

  // ============================
  // 抽卡歷史紀錄
  // ============================
  function addHistory(deckKey, cardFile) {
    const deck = DECKS[deckKey];
    const now = new Date();
    history.unshift({
      time: now.toLocaleString(),
      deckId: deckKey,
      deckLabel: deck?.label || deckKey,
      card: cardFile,
      img: deck ? deck.path + cardFile : ''
    });
    // 最多保留 200 筆
    if (history.length > 200) history.length = 200;
    saveHistory();
  }

  function buildHistoryFilterOptions() {
    if (!historyFilterSelect) return;

    const current = historyFilterSelect.value;
    const map = new Map(); // deckId -> deckLabel
    history.forEach(h => {
      if (!map.has(h.deckId)) {
        map.set(h.deckId, h.deckLabel);
      }
    });

    historyFilterSelect.innerHTML = '<option value="">全部牌組</option>';
    map.forEach((label, id) => {
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = label;
      historyFilterSelect.appendChild(opt);
    });

    if (current && map.has(current)) {
      historyFilterSelect.value = current;
    }
  }

  function renderHistory() {
    const list = document.getElementById('historyList');
    const empty = document.getElementById('historyEmpty');
    list.innerHTML = '';

    buildHistoryFilterOptions();
    const filterDeckId = historyFilterSelect ? historyFilterSelect.value : '';

    const filtered = filterDeckId
      ? history.filter(h => h.deckId === filterDeckId)
      : history;

    if (filtered.length === 0) {
      empty.classList.remove('d-none');
      return;
    }
    empty.classList.add('d-none');

    filtered.forEach(item => {
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex align-items-center';

      if (item.img) {
        const thumb = document.createElement('img');
        thumb.src = item.img;
        thumb.alt = item.card;
        thumb.style.width = '60px';
        thumb.style.height = '60px';
        thumb.style.objectFit = 'cover';
        thumb.className = 'me-3 rounded border';
        li.appendChild(thumb);
      }

      const info = document.createElement('div');
      info.innerHTML = `
        <div><strong>${item.deckLabel}</strong></div>
        <div>卡片：${item.card}</div>
        <div class="text-muted small">${item.time}</div>
      `;
      li.appendChild(info);

      list.appendChild(li);
    });
  }

  // Modal 打開時渲染
  const historyModal = document.getElementById('historyModal');
  historyModal.addEventListener('show.bs.modal', renderHistory);

  document.getElementById('btnClearHistory').addEventListener('click', () => {
    history.length = 0;
    saveHistory();
    renderHistory();
  });

  if (historyFilterSelect) {
    historyFilterSelect.addEventListener('change', renderHistory);
  }

  // ============================
  // 抽卡流程（滑順轉輪 + 可控制是否重複）
  // ============================
  let spinning = false;

  function randomPick(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function showCard(deckKey, filename) {
    const deck = DECKS[deckKey];
    if (!deck) return;
    $("#card-img").attr("src", deck.path + filename);
  }

  async function startSpin() {
    const deckKey = $("#deckSelect").val();
    if (!deckKey) {
      alert("請先選擇牌組");
      return;
    }

    const deck = DECKS[deckKey];
    if (!deck || !Array.isArray(deck.cards) || deck.cards.length === 0) {
      alert("此牌組沒有卡片，請檢查 decks.json。");
      return;
    }

    if (spinning) return;
    spinning = true;

    // 儲存最後使用牌組
    savePreferences();

    // 抽卡前先確保該牌組已預載完畢
    $("#btnDraw").prop("disabled", true).text("載入中…");
    try {
      await preloadDeck(deckKey);
    } catch (e) {
      console.warn('預載牌組失敗', e);
    }

    $("#btnDraw").text("抽牌中…");

    // 是否允許重複出卡
    const allowDup = allowDupCheckbox.checked;
    let candidates = deck.cards;

    if (!allowDup) {
      let usedSet = usedCardsByDeck[deckKey];
      if (!usedSet) {
        usedSet = usedCardsByDeck[deckKey] = new Set();
      }

      let available = deck.cards.filter(c => !usedSet.has(c));
      if (available.length === 0) {
        const reset = confirm('此牌組所有卡片都已抽完，要重新洗牌嗎？');
        if (!reset) {
          spinning = false;
          $("#btnDraw").prop("disabled", false).text("開始抽卡");
          return;
        }
        usedSet.clear();
        available = deck.cards.slice();
      }
      candidates = available;
    }

    let totalTime = parseFloat($("#spinDuration").val()) || 2;
    if (totalTime < 0.5) totalTime = 0.5;
    totalTime *= 1000;

    let start = performance.now();
    let lastFrame = 0;

    function spinFrame(now) {
      const elapsed = now - start;
      const t = Math.min(elapsed / totalTime, 1); // 0 → 1

      // 減速曲線（Ease-out cubic）
      const ease = 1 - Math.pow(1 - t, 3);

      // 轉動速度：一開始超快 → 越來越慢
      const minSpeed = 40;   // 最慢 (ms)
      const maxSpeed = 30;   // 最快 (ms)
      const currentSpeed = maxSpeed + (minSpeed - maxSpeed) * ease;

      if (now - lastFrame >= currentSpeed) {
        showCard(deckKey, randomPick(candidates));
        playSlotTick();
        lastFrame = now;
      }

      if (t < 1) {
        requestAnimationFrame(spinFrame);
      } else {
        // 轉完 → 最終結果
        const finalCard = randomPick(candidates);
        showCard(deckKey, finalCard);
        addHistory(deckKey, finalCard);

        if (!allowDup) {
          let usedSet = usedCardsByDeck[deckKey];
          if (!usedSet) usedSet = usedCardsByDeck[deckKey] = new Set();
          usedSet.add(finalCard);
        }

        setTimeout(() => playFinalStop(), 120);

        spinning = false;
        $("#btnDraw").prop("disabled", false).text("開始抽卡");
      }
    }

    requestAnimationFrame(spinFrame);
  }

  // ============================
  // 初始化
  // ============================
  $(function () {
    loadPreferencesFromLocalStorage();   // 還原 localStorage 設定
    loadDecksFromJson();                // 從 JSON 載入牌組

    $("#btnDraw").on("click", startSpin);
    $("#btnTestSound").on("click", testSound);

    // 換牌組時，也先預載該牌組，並短暫鎖住按鈕
    $("#deckSelect").on("change", async function () {
      savePreferences();
      const deckKey = this.value;
      if (!deckKey) return;

      $("#btnDraw").prop("disabled", true).text("載入中…");
      try {
        await preloadDeck(deckKey);
      } catch (e) {
        console.warn('預載牌組失敗(on change)', e);
      }
      $("#btnDraw").prop("disabled", false).text("開始抽卡");
    });
  });
</script>

</body>
</html>
